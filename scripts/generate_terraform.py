from dotenv import load_dotenv

load_dotenv()

"""
Generate Terraform HCL files from SnowDDL YAML configurations.

Converts SnowDDL YAML infrastructure definitions into Terraform-compatible
HCL or JSON files for the Snowflake-Labs/snowflake provider.

Usage:
    uv run generate-terraform                          # Print to stdout
    uv run generate-terraform --output ./terraform/    # Write separate .tf files
    uv run generate-terraform --format json            # JSON output
"""

import argparse
import json
import re
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import yaml


# ---------------------------------------------------------------------------
# Custom YAML loader that handles the !decrypt tag gracefully
# ---------------------------------------------------------------------------

class SafeLoaderWithDecrypt(yaml.SafeLoader):
    """YAML loader that treats !decrypt tagged values as placeholder strings."""
    pass


def _decrypt_constructor(loader: yaml.SafeLoader, node: yaml.ScalarNode) -> str:
    """Return a placeholder for encrypted values."""
    return "<ENCRYPTED>"


SafeLoaderWithDecrypt.add_constructor("!decrypt", _decrypt_constructor)


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

WAREHOUSE_SIZE_MAP = {
    "X-Small": "XSMALL",
    "x-small": "XSMALL",
    "xsmall": "XSMALL",
    "Small": "SMALL",
    "small": "SMALL",
    "Medium": "MEDIUM",
    "medium": "MEDIUM",
    "Large": "LARGE",
    "large": "LARGE",
    "X-Large": "XLARGE",
    "x-large": "XLARGE",
    "xlarge": "XLARGE",
    "2X-Large": "XXLARGE",
    "2x-large": "XXLARGE",
    "3X-Large": "XXXLARGE",
    "3x-large": "XXXLARGE",
    "4X-Large": "X4LARGE",
    "4x-large": "X4LARGE",
}

HEADER = """\
# Generated by SnowTower - DO NOT EDIT MANUALLY
# Source: snowddl/ YAML configurations
"""

PROVIDER_BLOCK = """\
terraform {
  required_providers {
    snowflake = {
      source  = "Snowflake-Labs/snowflake"
      version = "~> 1.0"
    }
  }
}
"""


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def to_tf_name(name: str) -> str:
    """Convert a Snowflake object name to a valid Terraform resource name.

    Rules:
    - Lowercase
    - Replace non-alphanumeric characters with underscores
    - Strip leading/trailing underscores
    - Collapse consecutive underscores
    """
    result = name.lower()
    result = re.sub(r"[^a-z0-9]", "_", result)
    result = re.sub(r"_+", "_", result)
    result = result.strip("_")
    return result


def hcl_value(value: Any) -> str:
    """Format a Python value as an HCL literal."""
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, int):
        return str(value)
    if isinstance(value, float):
        return str(value)
    if isinstance(value, str):
        # Escape backslashes and quotes inside the string
        escaped = value.replace("\\", "\\\\").replace('"', '\\"')
        return f'"{escaped}"'
    if isinstance(value, list):
        items = ", ".join(hcl_value(v) for v in value)
        return f"[{items}]"
    return f'"{value}"'


def hcl_block(resource_type: str, resource_name: str, attrs: Dict[str, Any],
              import_id: Optional[str] = None) -> str:
    """Render a single Terraform resource block as HCL.

    Parameters
    ----------
    resource_type : str
        e.g. ``snowflake_user``
    resource_name : str
        The Terraform resource name (snake_case)
    attrs : dict
        Key/value pairs for the resource body
    import_id : str, optional
        If provided an ``import {}`` block is emitted before the resource.
    """
    lines: List[str] = []

    if import_id is not None:
        lines.append(f'import {{')
        lines.append(f'  to = {resource_type}.{resource_name}')
        lines.append(f'  id = "{import_id}"')
        lines.append(f'}}')
        lines.append("")

    lines.append(f'resource "{resource_type}" "{resource_name}" {{')
    max_key_len = max((len(k) for k in attrs), default=0)

    for key, value in attrs.items():
        if isinstance(value, dict):
            # Nested block (e.g. triggers in resource monitors)
            lines.append(f"  {key} {{")
            for nk, nv in value.items():
                lines.append(f"    {nk:{max_key_len}} = {hcl_value(nv)}")
            lines.append("  }")
        else:
            lines.append(f"  {key:{max_key_len}} = {hcl_value(value)}")

    lines.append("}")
    return "\n".join(lines)


def load_yaml(path: Path) -> Optional[Dict]:
    """Load a YAML file, returning None if missing or empty."""
    if not path.exists():
        return None
    with open(path) as f:
        data = yaml.load(f, Loader=SafeLoaderWithDecrypt)
    return data if isinstance(data, dict) else None


# ---------------------------------------------------------------------------
# Generators -- each returns a list of HCL strings
# ---------------------------------------------------------------------------

def generate_users(snowddl_dir: Path) -> List[str]:
    """Generate snowflake_user resources from user.yaml."""
    data = load_yaml(snowddl_dir / "user.yaml")
    if not data:
        return []

    blocks: List[str] = []
    for name, cfg in sorted(data.items()):
        attrs: Dict[str, Any] = {"name": name}
        for yaml_key, tf_key in [
            ("email", "email"),
            ("first_name", "first_name"),
            ("last_name", "last_name"),
            ("default_role", "default_role"),
            ("comment", "comment"),
            ("type", "user_type"),
        ]:
            if yaml_key in cfg:
                attrs[tf_key] = cfg[yaml_key]

        if "rsa_public_key" in cfg:
            raw_key = cfg["rsa_public_key"].strip()
            attrs["rsa_public_key"] = raw_key

        tf_name = to_tf_name(name)
        blocks.append(hcl_block("snowflake_user", tf_name, attrs, import_id=name))

    return blocks


def generate_warehouses(snowddl_dir: Path) -> List[str]:
    """Generate snowflake_warehouse resources from warehouse.yaml."""
    data = load_yaml(snowddl_dir / "warehouse.yaml")
    if not data:
        return []

    blocks: List[str] = []
    for name, cfg in sorted(data.items()):
        size_raw = cfg.get("size", "X-Small")
        size_tf = WAREHOUSE_SIZE_MAP.get(size_raw, size_raw.upper().replace("-", ""))

        attrs: Dict[str, Any] = {
            "name": name,
            "warehouse_size": size_tf,
        }

        if "auto_suspend" in cfg:
            attrs["auto_suspend"] = cfg["auto_suspend"]
        attrs["auto_resume"] = cfg.get("auto_resume", True)

        for yaml_key, tf_key in [
            ("comment", "comment"),
            ("resource_monitor", "resource_monitor"),
            ("min_cluster_count", "min_cluster_count"),
            ("max_cluster_count", "max_cluster_count"),
        ]:
            if yaml_key in cfg:
                attrs[tf_key] = cfg[yaml_key]

        tf_name = to_tf_name(name)
        blocks.append(hcl_block("snowflake_warehouse", tf_name, attrs, import_id=name))

    return blocks


def generate_business_roles(snowddl_dir: Path) -> Tuple[List[str], List[str]]:
    """Generate snowflake_account_role and grant resources from business_role.yaml.

    Returns (role_blocks, grant_blocks).
    """
    data = load_yaml(snowddl_dir / "business_role.yaml")
    if not data:
        return [], []

    role_blocks: List[str] = []
    grant_blocks: List[str] = []

    for name, cfg in sorted(data.items()):
        sf_role_name = f"{name}__B_ROLE"
        tf_name = to_tf_name(sf_role_name)

        attrs = {
            "name": sf_role_name,
        }
        if "comment" in cfg:
            attrs["comment"] = cfg["comment"]

        role_blocks.append(hcl_block("snowflake_account_role", tf_name, attrs,
                                     import_id=sf_role_name))

        # Tech role inheritance grants
        for tech_role in cfg.get("tech_roles", []):
            tech_sf_name = f"{tech_role}__T_ROLE"
            grant_tf_name = to_tf_name(f"{sf_role_name}_inherits_{tech_sf_name}")
            grant_attrs = {
                "role_name": tech_sf_name,
                "parent_role_name": sf_role_name,
            }
            grant_blocks.append(hcl_block(
                "snowflake_grant_account_role", grant_tf_name, grant_attrs))

        # Warehouse usage grants
        for wh in cfg.get("warehouse_usage", []):
            grant_tf_name = to_tf_name(f"{sf_role_name}_wh_{wh}")
            grant_attrs = {
                "account_role_name": sf_role_name,
                "privileges": ["USAGE"],
                "on_account_object": {"object_type": "WAREHOUSE", "object_name": wh},
            }
            grant_blocks.append(hcl_block(
                "snowflake_grant_privileges_to_account_role", grant_tf_name, grant_attrs))

        # Schema owner grants
        for schema_ref in cfg.get("schema_owner", []):
            parts = schema_ref.split(".")
            if len(parts) == 2:
                db, schema = parts
                owner_role = f"{db}__{schema}__OWNER__S_ROLE"
                grant_tf_name = to_tf_name(f"{sf_role_name}_owner_{db}_{schema}")
                grant_attrs = {
                    "role_name": owner_role,
                    "parent_role_name": sf_role_name,
                }
                grant_blocks.append(hcl_block(
                    "snowflake_grant_account_role", grant_tf_name, grant_attrs))

    return role_blocks, grant_blocks


def _parse_grant_key(grant_key: str) -> Tuple[str, List[str]]:
    """Parse a SnowDDL grant key like ``DATABASE:USAGE,CREATE SCHEMA``.

    Returns (object_type, privilege_list).
    """
    parts = grant_key.split(":", 1)
    obj_type = parts[0]
    privileges = [p.strip() for p in parts[1].split(",")]
    return obj_type, privileges


def generate_tech_roles(snowddl_dir: Path) -> Tuple[List[str], List[str]]:
    """Generate snowflake_account_role and grant resources from tech_role.yaml.

    Returns (role_blocks, grant_blocks).
    """
    data = load_yaml(snowddl_dir / "tech_role.yaml")
    if not data:
        return [], []

    role_blocks: List[str] = []
    grant_blocks: List[str] = []

    for name, cfg in sorted(data.items()):
        sf_role_name = f"{name}__T_ROLE"
        tf_name = to_tf_name(sf_role_name)

        attrs = {"name": sf_role_name}
        if "comment" in cfg:
            attrs["comment"] = cfg["comment"]

        role_blocks.append(hcl_block("snowflake_account_role", tf_name, attrs,
                                     import_id=sf_role_name))

        # Regular grants
        for grant_key, targets in (cfg.get("grants") or {}).items():
            obj_type, privileges = _parse_grant_key(grant_key)
            if not targets:
                continue
            for target in targets:
                grant_tf_name = to_tf_name(
                    f"{sf_role_name}_grant_{obj_type}_{target}_{'_'.join(privileges)}"
                )
                grant_attrs: Dict[str, Any] = {
                    "account_role_name": sf_role_name,
                    "privileges": privileges,
                }

                if obj_type == "SCHEMA":
                    # target is DATABASE.SCHEMA
                    grant_attrs["on_schema"] = {
                        "schema_name": f'"{target}"',
                    }
                elif obj_type in ("DATABASE", "WAREHOUSE"):
                    grant_attrs["on_account_object"] = {
                        "object_type": obj_type,
                        "object_name": target,
                    }
                else:
                    grant_attrs["on_account_object"] = {
                        "object_type": obj_type,
                        "object_name": target,
                    }

                grant_blocks.append(hcl_block(
                    "snowflake_grant_privileges_to_account_role",
                    grant_tf_name, grant_attrs))

        # Future grants
        for grant_key, targets in (cfg.get("future_grants") or {}).items():
            obj_type, privileges = _parse_grant_key(grant_key)
            if not targets:
                continue
            for target in targets:
                grant_tf_name = to_tf_name(
                    f"{sf_role_name}_future_{obj_type}_{target}_{'_'.join(privileges)}"
                )
                grant_attrs = {
                    "account_role_name": sf_role_name,
                    "privileges": privileges,
                    "on_schema_object": {
                        "object_type_plural": f"{obj_type}S",
                        "in_database": target,
                    },
                    "all_privileges": False,
                    "with_grant_option": False,
                }

                grant_blocks.append(hcl_block(
                    "snowflake_grant_privileges_to_account_role",
                    grant_tf_name, grant_attrs))

    return role_blocks, grant_blocks


def generate_network_policies(snowddl_dir: Path) -> List[str]:
    """Generate snowflake_network_policy resources from network_policy.yaml."""
    data = load_yaml(snowddl_dir / "network_policy.yaml")
    if not data:
        return []

    blocks: List[str] = []
    for name, cfg in sorted(data.items()):
        sf_name = name.upper()
        attrs: Dict[str, Any] = {"name": sf_name}

        if "allowed_ip_list" in cfg:
            attrs["allowed_ip_list"] = cfg["allowed_ip_list"]
        if "comment" in cfg:
            attrs["comment"] = cfg["comment"]

        tf_name = to_tf_name(name)
        blocks.append(hcl_block("snowflake_network_policy", tf_name, attrs,
                                import_id=sf_name))

    return blocks


def generate_authentication_policies(snowddl_dir: Path) -> List[str]:
    """Generate snowflake_authentication_policy resources."""
    data = load_yaml(snowddl_dir / "authentication_policy.yaml")
    if not data:
        return []

    blocks: List[str] = []
    for name, cfg in sorted(data.items()):
        sf_name = name.upper()
        attrs: Dict[str, Any] = {"name": sf_name}

        for yaml_key, tf_key in [
            ("comment", "comment"),
            ("client_types", "client_types"),
            ("mfa_authentication_methods", "mfa_authentication_methods"),
            ("mfa_enrollment", "mfa_enrollment"),
            ("authentication_methods", "authentication_methods"),
            ("security_integrations", "security_integrations"),
        ]:
            if yaml_key in cfg:
                attrs[tf_key] = cfg[yaml_key]

        tf_name = to_tf_name(name)
        blocks.append(hcl_block("snowflake_authentication_policy", tf_name, attrs,
                                import_id=sf_name))

    return blocks


def generate_password_policies(snowddl_dir: Path) -> List[str]:
    """Generate snowflake_password_policy resources."""
    data = load_yaml(snowddl_dir / "password_policy.yaml")
    if not data:
        return []

    blocks: List[str] = []
    for name, cfg in sorted(data.items()):
        sf_name = name.upper()
        attrs: Dict[str, Any] = {"name": sf_name}

        # Map all password_* fields and other known fields
        for key, value in sorted(cfg.items()):
            if key == "comment_in_sql":
                continue  # SnowDDL-specific, not relevant for Terraform
            attrs[key] = value

        tf_name = to_tf_name(name)
        blocks.append(hcl_block("snowflake_password_policy", tf_name, attrs,
                                import_id=sf_name))

    return blocks


def generate_session_policies(snowddl_dir: Path) -> List[str]:
    """Generate snowflake_session_policy resources."""
    data = load_yaml(snowddl_dir / "session_policy.yaml")
    if not data:
        return []

    blocks: List[str] = []
    for name, cfg in sorted(data.items()):
        sf_name = name.upper()
        attrs: Dict[str, Any] = {"name": sf_name}

        for key, value in sorted(cfg.items()):
            if key == "comment_in_sql":
                continue
            attrs[key] = value

        tf_name = to_tf_name(name)
        blocks.append(hcl_block("snowflake_session_policy", tf_name, attrs,
                                import_id=sf_name))

    return blocks


def generate_resource_monitors(snowddl_dir: Path) -> List[str]:
    """Generate snowflake_resource_monitor resources from resource_monitor.yaml."""
    data = load_yaml(snowddl_dir / "resource_monitor.yaml")
    if not data:
        return []

    blocks: List[str] = []
    for name, cfg in sorted(data.items()):
        attrs: Dict[str, Any] = {"name": name}

        if "credit_quota" in cfg:
            attrs["credit_quota"] = cfg["credit_quota"]
        if "frequency" in cfg:
            attrs["frequency"] = cfg["frequency"]

        # Parse triggers into separate lists
        triggers = cfg.get("triggers", {})
        notify_triggers: List[int] = []
        suspend_triggers: List[int] = []
        suspend_immediate_triggers: List[int] = []

        for threshold, action in sorted(triggers.items()):
            action_upper = str(action).upper()
            if action_upper == "NOTIFY":
                notify_triggers.append(int(threshold))
            elif action_upper == "SUSPEND":
                suspend_triggers.append(int(threshold))
            elif action_upper == "SUSPEND_IMMEDIATE":
                suspend_immediate_triggers.append(int(threshold))

        if notify_triggers:
            attrs["notify_triggers"] = notify_triggers
        if suspend_triggers:
            attrs["suspend_triggers"] = suspend_triggers
        if suspend_immediate_triggers:
            attrs["suspend_immediate_triggers"] = suspend_immediate_triggers

        tf_name = to_tf_name(name)
        blocks.append(hcl_block("snowflake_resource_monitor", tf_name, attrs,
                                import_id=name))

    return blocks


def generate_databases(snowddl_dir: Path) -> List[str]:
    """Generate snowflake_database resources from database directories."""
    blocks: List[str] = []

    for params_path in sorted(snowddl_dir.glob("*/params.yaml")):
        db_name = params_path.parent.name
        cfg = load_yaml(params_path) or {}

        attrs: Dict[str, Any] = {"name": db_name}

        if "comment" in cfg:
            attrs["comment"] = cfg["comment"]
        if cfg.get("is_sandbox"):
            attrs["comment"] = attrs.get("comment", f"Sandbox database {db_name}")

        tf_name = to_tf_name(db_name)
        blocks.append(hcl_block("snowflake_database", tf_name, attrs,
                                import_id=db_name))

    return blocks


# ---------------------------------------------------------------------------
# Output formatting
# ---------------------------------------------------------------------------

@dataclass
class TerraformOutput:
    """Holds all generated Terraform sections."""
    main: str = ""
    users: List[str] = field(default_factory=list)
    warehouses: List[str] = field(default_factory=list)
    roles: List[str] = field(default_factory=list)
    grants: List[str] = field(default_factory=list)
    policies: List[str] = field(default_factory=list)
    databases: List[str] = field(default_factory=list)
    resource_monitors: List[str] = field(default_factory=list)


def generate_all(snowddl_dir: Path) -> TerraformOutput:
    """Run all generators and return structured output."""
    output = TerraformOutput()
    output.main = PROVIDER_BLOCK

    # Users
    output.users = generate_users(snowddl_dir)

    # Warehouses
    output.warehouses = generate_warehouses(snowddl_dir)

    # Business roles
    b_role_blocks, b_grant_blocks = generate_business_roles(snowddl_dir)

    # Tech roles
    t_role_blocks, t_grant_blocks = generate_tech_roles(snowddl_dir)

    output.roles = b_role_blocks + t_role_blocks
    output.grants = b_grant_blocks + t_grant_blocks

    # Policies (network, authentication, password, session)
    output.policies = (
        generate_network_policies(snowddl_dir)
        + generate_authentication_policies(snowddl_dir)
        + generate_password_policies(snowddl_dir)
        + generate_session_policies(snowddl_dir)
    )

    # Resource monitors
    output.resource_monitors = generate_resource_monitors(snowddl_dir)

    # Databases
    output.databases = generate_databases(snowddl_dir)

    return output


def render_section(header_comment: str, blocks: List[str]) -> str:
    """Combine blocks into a single string with a section header."""
    if not blocks:
        return ""
    lines = [HEADER, f"# {header_comment}", ""]
    lines.append("\n\n".join(blocks))
    lines.append("")
    return "\n".join(lines)


def write_to_directory(output: TerraformOutput, out_dir: Path) -> None:
    """Write separate .tf files into the output directory."""
    out_dir.mkdir(parents=True, exist_ok=True)

    files = {
        "main.tf": HEADER + "\n" + output.main,
        "users.tf": render_section("User resources", output.users),
        "warehouses.tf": render_section("Warehouse resources", output.warehouses),
        "roles.tf": render_section("Role resources (business + tech)", output.roles),
        "grants.tf": render_section("Grant resources", output.grants),
        "policies.tf": render_section(
            "Policy resources (network, authentication, password, session)",
            output.policies),
        "databases.tf": render_section("Database resources", output.databases),
        "resource_monitors.tf": render_section(
            "Resource monitor resources", output.resource_monitors),
    }

    for filename, content in files.items():
        if not content.strip():
            continue
        filepath = out_dir / filename
        filepath.write_text(content)
        print(f"  Wrote {filepath}")


def write_to_stdout(output: TerraformOutput, fmt: str) -> None:
    """Print combined output to stdout."""
    if fmt == "json":
        # Collect a simple representation for JSON output
        combined = {
            "main": output.main,
            "users": output.users,
            "warehouses": output.warehouses,
            "roles": output.roles,
            "grants": output.grants,
            "policies": output.policies,
            "databases": output.databases,
            "resource_monitors": output.resource_monitors,
        }
        print(json.dumps(combined, indent=2))
        return

    # HCL to stdout -- combine all sections
    sections = [
        (HEADER + "\n" + output.main),
        render_section("User resources", output.users),
        render_section("Warehouse resources", output.warehouses),
        render_section("Role resources (business + tech)", output.roles),
        render_section("Grant resources", output.grants),
        render_section("Policy resources (network, auth, password, session)",
                       output.policies),
        render_section("Database resources", output.databases),
        render_section("Resource monitor resources", output.resource_monitors),
    ]

    print("\n".join(s for s in sections if s.strip()))


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate Terraform HCL files from SnowDDL YAML configurations.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""\
Examples:
  uv run generate-terraform                          # Print HCL to stdout
  uv run generate-terraform --output ./terraform/    # Write separate .tf files
  uv run generate-terraform --format json            # JSON output to stdout
""",
    )
    parser.add_argument(
        "--output", "-o",
        type=str,
        default=None,
        help="Output directory for .tf files. If omitted, prints to stdout.",
    )
    parser.add_argument(
        "--format", "-f",
        choices=["hcl", "json"],
        default="hcl",
        dest="fmt",
        help="Output format (default: hcl).",
    )
    parser.add_argument(
        "--snowddl-dir",
        type=str,
        default=None,
        help="Path to snowddl/ directory (auto-detected from project root).",
    )
    args = parser.parse_args()

    # Resolve snowddl directory
    if args.snowddl_dir:
        snowddl_dir = Path(args.snowddl_dir)
    else:
        # Walk up from this script to find snowddl/
        project_root = Path(__file__).resolve().parent.parent
        snowddl_dir = project_root / "snowddl"

    if not snowddl_dir.is_dir():
        print(f"Error: snowddl directory not found at {snowddl_dir}", file=sys.stderr)
        sys.exit(1)

    print(f"Reading SnowDDL configs from: {snowddl_dir}", file=sys.stderr)

    output = generate_all(snowddl_dir)

    if args.output:
        out_dir = Path(args.output)
        print(f"Writing Terraform files to: {out_dir}", file=sys.stderr)
        write_to_directory(output, out_dir)
        print(f"\nDone. Generated Terraform files in {out_dir}", file=sys.stderr)
    else:
        write_to_stdout(output, args.fmt)


if __name__ == "__main__":
    main()
